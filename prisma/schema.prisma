// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model User {
  id                     String      @id @map("_id")
  email                  String      @unique
  files                  File[]
  projects               Project[]
  questions              Question[]
  messages               Message[]
  stripeCustomerId       String?     @unique @map(name: "stripe_customer_id")
  stripeSubscriptionId   String?     @unique @map(name: "stripe_subscription_id")
  stripePriceId          String?     @map(name: "stripe_price_id")
  stripeCurrentPeriodEnd DateTime?   @map(name: "stripe_current_period_end")
  TokenCost              TokenCost[]
  QueryCost              QueryCost[]
}

enum UploadStatus {
  PENDING
  PROCESSING
  FAILED
  SUCCESS
}

model File {
  id           String       @id @map("_id")
  fileId       String?      @default(cuid())
  name         String
  uploadStatus UploadStatus @default(PENDING)
  url          String
  key          String
  User         User         @relation(fields: [kindeId], references: [id])
  kindeId      String
  projects     Project[]    @relation(fields: [projectIds], references: [id])
  projectIds   String[]     @db.ObjectId
  questions    Question[]   @relation(fields: [questionIds], references: [id])
  questionIds  String[]     @db.ObjectId
  messages     Message[]
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
}

model Message {
  id            String      @id @default(auto()) @map("_id") @db.ObjectId
  text          String
  isUserMessage Boolean // so we can differenciate between user messages and ai messages
  updatedAt     DateTime    @updatedAt
  User          User        @relation(fields: [kindeId], references: [id])
  kindeId       String
  File          File?       @relation(fields: [fileId], references: [id])
  fileId        String?
  Project       Project?    @relation(fields: [projectId], references: [id])
  projectId     String?     @db.ObjectId
  Question      Question?   @relation(fields: [questionId], references: [id])
  questionId    String?     @db.ObjectId
  isPinned      Boolean     @default(false)
  QueryCost     QueryCost[]
  createdAt     DateTime    @default(now())
}

model Project {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  kindeId   String
  User      User       @relation(fields: [kindeId], references: [id])
  fileIds   String[]
  Files     File[]     @relation(fields: [fileIds], references: [id])
  questions Question[]
  messages  Message[]
}

model Question {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  kindeId          String
  User             User?      @relation(fields: [kindeId], references: [id])
  File             File[]     @relation(fields: [fileIds], references: [id])
  fileIds          String[]
  projectId        String?    @db.ObjectId
  Project          Project?   @relation(fields: [projectId], references: [id])
  parentQuestionId String?    @db.ObjectId
  parentQuestion   Question?  @relation("ParentChild", fields: [parentQuestionId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  subQuestions     Question[] @relation("ParentChild")
  messages         Message[]
}

enum ContextType {
  PREV_MESSAGES
  PINNED_MESSAGES
  QUERY_MESSAGE
  QUESTIONS
  NOTES
  GPT_COMPLETION
  VECTOR_STORES
}

model TokenCost {
  id          String      @id @default(auto()) @map("_id") @db.ObjectId
  kindeId     String
  User        User?       @relation(fields: [kindeId], references: [id])
  contextType ContextType
  gptModel    String
  totalTokens BigInt
  QueryCost   QueryCost?  @relation(fields: [queryCostId], references: [id])
  queryCostId String      @db.ObjectId
  createdAt   DateTime    @default(now())
  // nTokenRate  BigInt
}

model QueryCost {
  id         String      @id @default(auto()) @map("_id") @db.ObjectId
  kindeId    String
  User       User        @relation(fields: [kindeId], references: [id])
  message    Message?    @relation(fields: [messageId], references: [id])
  messageId  String?     @db.ObjectId
  questionId String?     @db.ObjectId
  projectId  String?     @db.ObjectId
  createdAt  DateTime    @default(now())
  TokenCost  TokenCost[]
}
